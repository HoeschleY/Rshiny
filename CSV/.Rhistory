print(url_encoded)
response <- GET(url_encoded)
# Print response status
print(status_code(response))
# Convert content from the response to a readable format
content <- fromJSON(rawToChar(response$content), flatten = FALSE)
# Check the total number of records available
total <- content$total
print(total)
# Append new data to df_69
df_69 <- rbind(df_69, content$result)
# Check if there are more records to fetch
start <- start + size
if (start >= total) {
has_more <- FALSE
}
}
}
nrow(df_69)/length(code)
nrow(df_69)
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
# install.packages("rmarkdown")
# install.packages("shiny")
#install.packages("httr")
library(rmarkdown)
library(shiny)
library(httr)
#############################################################
# Encodage des paramètres
url_encoded <- modify_url(base_url, query = params)
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
# install.packages("rmarkdown")
# install.packages("shiny")
#install.packages("httr")
library(rmarkdown)
library(shiny)
library(httr)
#############################################################
# Encodage des paramètres
url_encoded <- modify_url(base_url, query = params)
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
install.packages(c("httr", "jsonlite"))
# Install dplyr if not already installed
install.packages("dplyr")
# Load the dplyr package
library(dplyr)
library(httr)
library(jsonlite)
dfexist = read.csv(file ="dpe-v2-logements-existants.csv", header = TRUE, sep = ",",dec = '.')
dfneuf = read.csv(file ="dpe-v2-logements-neufs.csv", header = TRUE, sep = ",",dec = '.')
#
# View(dfneuf)
# View(dfexist)
#
# dim(dfneuf)
# dim(dfexist)
#
# dfneuf$Logement = "Neuf"
#
# dfneuf$Période_construction = "après 2021"
#
# dfexist$Logement = "Ancien"
#
# col_communes = intersect(colnames(dfexist),colnames(dfneuf))
#
# df = rbind(dfexist[ ,col_communes],dfneuf[ ,col_communes])
# View(df)
#
# df$année = substr(df$Date_réception_DPE,0,4)
#
#
# df$verif = df$Coût_total_5_usages == df$Coût_chauffage + df$Coût_éclairage + df$Coût_ECS + df$Coût_refroidissement + df$Coût_auxiliaires
# table(df$verif)
# View(df)
#
# df$coût_chauffage_en_percent = (df$Coût_chauffage/(df$Coût_chauffage + df$Coût_éclairage + df$Coût_ECS + df$Coût_refroidissement + df$Coût_auxiliaires)) * 100
################ PARTIE 1 DONE
#
#
# table(df$Etiquette_DPE, useNA = "ifany")
#
# table(df$année, useNA = "ifany")
#
# table(df$Logement, useNA = "ifany")
#
# table(df$Type_bâtiment, useNA = "ifany")
#
# prop.table(table(df$Type_installation_chauffage, useNA = "ifany")) * 100
#
# table(df$Période_construction, useNA = "ifany")
#
# mean(df$Surface_habitable_logement,na.rm =TRUE)
#
# mean(df$Coût_chauffage,na.rm =TRUE)
#
# quantile(df$Coût_ECS,seq(0.1,1,0.1))
#
#
# cor(df$Surface_habitable_logement,df$Coût_chauffage,use = "complete.obs")
#
# install.packages('corrplot')
# library(corrplot)
#
# variables <- c("Coût_total_5_usages", "Coût_chauffage", "Coût_éclairage", "Coût_ECS", "Coût_refroidissement", "Coût_auxiliaires", "Surface_habitable_logement", "Emission_GES_5_usages")
#
# # Créez le corrélogramme
# corrplot(cor(df[, variables], use = "complete.obs"), method = "color", type = "upper")
#
# ###########PARTIE 2 DONE
#
# install.packages('dplyr')
# library(dplyr)
#
# df_avec_type_bat = filter(df,!is.na(Type_bâtiment))
#
# df_avec_type_bat_spe = filter(df,Etiquette_DPE %in% c("D","E","F","G"))
#
# df_avec_type_bat_vieux = filter(df,Période_construction == "avant 1948")
#
# df_avec_type_bat_grand = filter(df,Surface_habitable_logement > mean(Surface_habitable_logement,na.rm= TRUE))
#
# df_avec_type_bat_conso_base = arrange(df,desc(Conso_5_usages_par_m._é_primaire))
#
# c("Etiquette_DPE","Période_construction","Coût_chauffage")
# df_trier = arrange(df, desc(Etiquette_DPE), desc(Période_construction), desc(Coût_chauffage))
#
# ########### AGGREGATION
#
# aggregate(Coût_chauffage ~ Etiquette_DPE, data = df, FUN = mean, na.rm = TRUE)
#
# aggregate(Conso_5_usages_é_finale ~ Période_construction, data = df, FUN = mean, na.rm = TRUE)
#
# aggregate(Conso_5_usages_é_finale ~ Logement + Etiquette_DPE, data = df, FUN = mean, na.rm = TRUE)
#
# ###########GRAPH
#
#
# # Limiting the x-axis and increasing the bin size
# hist(df$Surface_habitable_logement,
install.packages(c("httr", "jsonlite"))
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
install.packages(c("httr", "jsonlite"))
# Install dplyr if not already installed
install.packages("dplyr")
# Load the dplyr package
library(dplyr)
library(httr)
library(jsonlite)
dfexist = read.csv(file ="dpe-v2-logements-existants.csv", header = TRUE, sep = ",",dec = '.')
dfneuf = read.csv(file ="dpe-v2-logements-neufs.csv", header = TRUE, sep = ",",dec = '.')
#
# View(dfneuf)
# View(dfexist)
#
# dim(dfneuf)
# dim(dfexist)
#
# dfneuf$Logement = "Neuf"
#
# dfneuf$Période_construction = "après 2021"
#
# dfexist$Logement = "Ancien"
#
# col_communes = intersect(colnames(dfexist),colnames(dfneuf))
#
# df = rbind(dfexist[ ,col_communes],dfneuf[ ,col_communes])
# View(df)
#
# df$année = substr(df$Date_réception_DPE,0,4)
#
#
# df$verif = df$Coût_total_5_usages == df$Coût_chauffage + df$Coût_éclairage + df$Coût_ECS + df$Coût_refroidissement + df$Coût_auxiliaires
# table(df$verif)
# View(df)
#
# df$coût_chauffage_en_percent = (df$Coût_chauffage/(df$Coût_chauffage + df$Coût_éclairage + df$Coût_ECS + df$Coût_refroidissement + df$Coût_auxiliaires)) * 100
################ PARTIE 1 DONE
#
#
# table(df$Etiquette_DPE, useNA = "ifany")
#
# table(df$année, useNA = "ifany")
#
# table(df$Logement, useNA = "ifany")
#
# table(df$Type_bâtiment, useNA = "ifany")
#
# prop.table(table(df$Type_installation_chauffage, useNA = "ifany")) * 100
#
# table(df$Période_construction, useNA = "ifany")
#
# mean(df$Surface_habitable_logement,na.rm =TRUE)
#
# mean(df$Coût_chauffage,na.rm =TRUE)
#
# quantile(df$Coût_ECS,seq(0.1,1,0.1))
#
#
# cor(df$Surface_habitable_logement,df$Coût_chauffage,use = "complete.obs")
#
# install.packages('corrplot')
# library(corrplot)
#
# variables <- c("Coût_total_5_usages", "Coût_chauffage", "Coût_éclairage", "Coût_ECS", "Coût_refroidissement", "Coût_auxiliaires", "Surface_habitable_logement", "Emission_GES_5_usages")
#
# # Créez le corrélogramme
# corrplot(cor(df[, variables], use = "complete.obs"), method = "color", type = "upper")
#
# ###########PARTIE 2 DONE
#
# install.packages('dplyr')
# library(dplyr)
#
# df_avec_type_bat = filter(df,!is.na(Type_bâtiment))
#
# df_avec_type_bat_spe = filter(df,Etiquette_DPE %in% c("D","E","F","G"))
#
# df_avec_type_bat_vieux = filter(df,Période_construction == "avant 1948")
#
# df_avec_type_bat_grand = filter(df,Surface_habitable_logement > mean(Surface_habitable_logement,na.rm= TRUE))
#
# df_avec_type_bat_conso_base = arrange(df,desc(Conso_5_usages_par_m._é_primaire))
#
# c("Etiquette_DPE","Période_construction","Coût_chauffage")
# df_trier = arrange(df, desc(Etiquette_DPE), desc(Période_construction), desc(Coût_chauffage))
#
# ########### AGGREGATION
#
# aggregate(Coût_chauffage ~ Etiquette_DPE, data = df, FUN = mean, na.rm = TRUE)
#
# aggregate(Conso_5_usages_é_finale ~ Période_construction, data = df, FUN = mean, na.rm = TRUE)
#
# aggregate(Conso_5_usages_é_finale ~ Logement + Etiquette_DPE, data = df, FUN = mean, na.rm = TRUE)
#
# ###########GRAPH
#
#
# # Limiting the x-axis and increasing the bin size
# hist(df$Surface_habitable_logement,
#      main = "Distribution des surfaces habitables",
#      xlab = "Surface habitable (m²)",
#      col = "lightblue",
#      border = "black",
#      breaks = 50,         # Increase bin size
#      xlim = c(0, 500))    # Limit the x-axis to 500 m²
#
#
# # Boxplot de la consommation annuelle des 5 usages en énergie
# boxplot(df$Conso_5_usages_é_finale,
#         main = "Distribution de la consommation annuelle des 5 usages en énergie",
#         ylab = "Consommation annuelle (kWhef/an)",
#         col = "lightgreen")
#
# # Boxplot du coût du chauffage selon l'étiquette DPE
# boxplot(df$Coût_chauffage ~ df$Etiquette_DPE,
#         main = "Coût du chauffage selon l'étiquette DPE",
#         xlab = "Étiquette DPE",
#         ylab = "Coût du chauffage (Euros)",
#         col = "lightcoral")
#
# # Diagramme en barre du nombre de logements par période de construction
# barplot(table(df$Période_construction),
#         main = "Nombre de logements par période de construction",
#         xlab = "Période de construction",
#         ylab = "Nombre de logements",
#         col = "lightblue",
#         las = 2)
#
# # Diagramme circulaire du principal type d'énergie
# pie(table(df$Type_énergie_n.1),
#     main = "Répartition du principal type d'énergie",
#     col = rainbow(length(unique(df$Type_énergie_n.1))))
#
#
# #########REGRESSION LINEAIRE
#
# plot(df$Surface_habitable_logement, df$Coût_chauffage,
#      xlab = "Surface habitable du logement",
#      ylab = "Coût du chauffage",
#      main = "Nuage de points: Surface habitable vs Coût du chauffage",
#      pch = 19) # pch = 19 pour des points pleins
#
#
# correlation <- cor(df$Surface_habitable_logement, df$Coût_chauffage, use = "complete.obs")
# print(correlation)
#
# modele <- lm(Coût_chauffage ~ Surface_habitable_logement, data = df)
# summary(modele)
#
# plot(df$Surface_habitable_logement, df$Coût_chauffage,
#      xlab = "Surface habitable du logement",
#      ylab = "Coût du chauffage",
#      main = "Nuage de points avec droite de régression",
#      pch = 19)
# abline(modele, col = "red") # Ajouter la droite de régression en rouge
#
#
# ##########CARTOGRAPHIE
# df_adresses <- read.csv("adresses-69.csv",sep = ";",dec = ".")
# install.packages("leaflet")
# library(leaflet)
#
#
# install.packages("ggmap")
# install.packages("ggplot2")
# library(ggmap)
# library(ggplot2)
#
# df$Identifiant__BAN <- as.character(df$Identifiant__BAN)
# df_adresses$id <- as.character(df_adresses$id)
#
# df_merged <- merge(df, df_adresses[, c("id", "lon", "lat")],
#                    by.x = "Identifiant__BAN", by.y = "id",
#                    all.x = TRUE)
#
# df_merged_clean <- df_merged %>%
#   filter(!is.na(lon) & !is.na(lat) &
#            lon >= -180 & lon <= 180 &
#            lat >= -90 & lat <= 90)
#
# leaflet() %>%
#   addTiles()
#
#
# leaflet(df_merged_clean) %>%
#   addTiles() %>%
#   addMarkers(lng = ~lon, lat = ~lat, popup = ~Adresse_brute)
#
#leaflet() %>%
#  addTiles() %>%
# addMarkers(lng = 2.3488, lat = 48.8534, popup = "Test Marker")  # Coordinates for Paris, France
#CHAPITRE 2
base_url <- "https://data.ademe.fr/data-fair/api/v1/datasets/dpe-v2-logements-existants/lines"
# Paramètres de la requête
params <- list(
page = 1,
size = 40,
select = "N°DPE,Code_postal_(BAN),Etiquette_DPE,Date_réception_DPE",
q = "69007",
q_fields = "Code_postal_(BAN)",
qs = "Date_réception_DPE:[2023-06-29 TO 2023-08-30]"
)
# Encodage des paramètres
url_encoded <- modify_url(base_url, query = params)
print(url_encoded)
# Effectuer la requête
response <- GET(url_encoded)
# Afficher le statut de la réponse
print(status_code(response))
# On convertit le contenu brut (octets) en une chaîne de caractères (texte). Cela permet de transformer les données reçues de l'API, qui sont généralement au format JSON, en une chaîne lisible par R
content = fromJSON(rawToChar(response$content), flatten = FALSE)
# Afficher le nombre total de ligne dans la base de données
print(content$total)
# Afficher les données récupérées
df <- content$result
dim(df)
View(df)
base_url <- "https://data.ademe.fr/data-fair/api/v1/datasets/dpe-v2-logements-existants/lines"
df_adresses <- read.csv("adresses-69.csv",sep = ";",dec = ".")
df_69 = data.frame()
code = unique(df_adresses$code_postal)
nrow(df_69)
nrow(df_69)/length(code)
View(df_69)
for(code_postal in code){
params <- list(
size = 10000,
select = "N°DPE,Code_postal_(BAN),Etiquette_DPE,Date_réception_DPE",
q = code_postal,
q_fields = "Code_postal_(BAN)",
qs = ""
)
url_encoded <- modify_url(base_url, query = params)
print(url_encoded)
response <- GET(url_encoded)
# Afficher le statut de la réponse
print(status_code(response))
print(code_postal)
# On convertit le contenu brut (octets) en une chaîne de caractères (texte). Cela permet de transformer les données reçues de l'API, qui sont généralement au format JSON, en une chaîne lisible par R
content = fromJSON(rawToChar(response$content), flatten = FALSE)
# Afficher le nombre total de ligne dans la base de données
print(content$total)
# Afficher les données récupérées
df_69 <- rbind(df_69,content$result)
}
for (code_postal in code) {
# Initialize variables
has_more <- TRUE
start <- 0
size <- 10000
while (has_more) {
# Prepare the request parameters
params <- list(
size = size,
select = "N°DPE,Code_postal_(BAN),Etiquette_DPE,Date_réception_DPE,Identifiant__BAN",
q = code_postal,
q_fields = "Code_postal_(BAN)",
qs = "",
start = start  # Add pagination using the start index
)
url_encoded <- modify_url(base_url, query = params)
print(url_encoded)
response <- GET(url_encoded)
# Print response status
print(status_code(response))
# Convert content from the response to a readable format
content <- fromJSON(rawToChar(response$content), flatten = FALSE)
# Check the total number of records available
total <- content$total
print(total)
# Append new data to df_69
df_69 <- rbind(df_69, content$result)
# Check if there are more records to fetch
start <- start + size
if (start >= total) {
has_more <- FALSE
}
}
}
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
gc()
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
rm(list = ls())
setwd("C:/Users/yanni/BUT/R/S2/CSV")
getwd()
# Install packages if not already installed
required_packages <- c("httr", "jsonlite", "dplyr", "leaflet", "ggmap", "ggplot2", "corrplot")
new_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)
# Load libraries
library(dplyr)
library(httr)
library(jsonlite)
library(leaflet)
library(ggmap)
library(ggplot2)
library(corrplot)
# API Call Logic
base_url <- "https://data.ademe.fr/data-fair/api/v1/datasets/dpe-v2-logements-existants/lines"
df_adresses <- read.csv("adresses-69.csv", sep = ";", dec = ".")
df_69 <- data.frame()
code <- unique(df_adresses$code_postal)
for (code_postal in code) {
# Initialize variables
has_more <- TRUE
start <- 0
size <- 10000
while (has_more) {
# Prepare the request parameters
params <- list(
size = size,
select = "N°DPE,Code_postal_(BAN),Etiquette_DPE,Date_réception_DPE,Identifiant__BAN",
q = code_postal,
q_fields = "Code_postal_(BAN)",
qs = "",
start = start  # Add pagination using the start index
)
url_encoded <- modify_url(base_url, query = params)
print(url_encoded)
response <- GET(url_encoded)
# Print response status
print(status_code(response))
# Convert content from the response to a readable format
content <- fromJSON(rawToChar(response$content), flatten = FALSE)
# Check the total number of records available
total <- content$total
print(total)
# Append new data to df_69
df_69 <- rbind(df_69, content$result)
# Check if there are more records to fetch
start <- start + size
if (start >= total) {
has_more <- FALSE
}
}
}
nrow(df_69)
nrow(df_69) / length(code)
View(df_69)
# Select only the columns "id", "lat", and "lon" from df_adresses
df_adresses_subset <- df_adresses[, c("id", "lat", "lon")]
# Rename the "id" column in df_adresses_subset to "Identifiant__BAN" to match df_69
df_adresses_subset <- rename(df_adresses_subset, Identifiant__BAN = id)
# Merge the two dataframes based on "Identifiant__BAN"
df_merged <- merge(df_69, df_adresses_subset, by = "Identifiant__BAN", all.x = TRUE)
# Filter out rows with missing lat/lon values
df_filtered <- df_merged[complete.cases(df_merged$lat, df_merged$lon), ]
write.csv(df_filtered, file = "df_filtered.csv", row.names = FALSE)
# Create the leaflet map
map <- leaflet(df_filtered) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addMarkers(
~lon, ~lat,  # Define longitude and latitude columns
popup = ~paste("Etiquette DPE:", Etiquette_DPE, "<br>",
"Postal Code:", `Code_postal_(BAN)`, "<br>",
"Reception Date:", Date_réception_DPE),  # Customize popup info
clusterOptions = markerClusterOptions()  # Enable marker clustering
)
# Show the map
map
